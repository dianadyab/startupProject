{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (C) 2016-2019 Michael Kourlas\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar xmlcreate_1 = require(\"xmlcreate\");\n\nvar options_1 = require(\"./options\");\n\nvar utils_1 = require(\"./utils\");\n/**\n * Indicates that an object of a particular type should be suppressed from the\n * XML output.\n *\n * See the `typeHandlers` property in {@link IOptions} for more details.\n */\n\n\nvar Absent =\n/** @class */\nfunction () {\n  function Absent() {}\n\n  Object.defineProperty(Absent, \"instance\", {\n    /**\n     * Returns the sole instance of Absent.\n     */\n    get: function get() {\n      return Absent._instance;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Absent._instance = new Absent();\n  return Absent;\n}();\n\nexports.Absent = Absent;\n/**\n * Gets the type handler associated with a value.\n *\n * @private\n */\n\nfunction getHandler(value, options) {\n  var type = Object.prototype.toString.call(value);\n  var handler;\n\n  if (options.typeHandlers.hasOwnProperty(\"*\")) {\n    handler = options.typeHandlers[\"*\"];\n  }\n\n  if (options.typeHandlers.hasOwnProperty(type)) {\n    handler = options.typeHandlers[type];\n  }\n\n  return handler;\n}\n/**\n * Parses a string into XML and adds it to the parent element or attribute.\n *\n * @private\n */\n\n\nfunction parseString(str, parentElement, options) {\n  var requiresCdata = function requiresCdata(s) {\n    return options.cdataInvalidChars && (s.indexOf(\"<\") !== -1 || s.indexOf(\"&\") !== -1) || options.cdataKeys.indexOf(parentElement.name) !== -1 || options.cdataKeys.indexOf(\"*\") !== -1;\n  };\n\n  if (parentElement instanceof xmlcreate_1.XmlElement) {\n    if (requiresCdata(str)) {\n      var cdataStrs = str.split(\"]]>\");\n\n      for (var i = 0; i < cdataStrs.length; i++) {\n        if (requiresCdata(cdataStrs[i])) {\n          parentElement.cdata({\n            charData: cdataStrs[i],\n            replaceInvalidCharsInCharData: options.replaceInvalidChars\n          });\n        } else {\n          parentElement.charData({\n            charData: cdataStrs[i],\n            replaceInvalidCharsInCharData: options.replaceInvalidChars\n          });\n        }\n\n        if (i < cdataStrs.length - 1) {\n          parentElement.charData({\n            charData: \"]]>\",\n            replaceInvalidCharsInCharData: options.replaceInvalidChars\n          });\n        }\n      }\n    } else {\n      parentElement.charData({\n        charData: str,\n        replaceInvalidCharsInCharData: options.replaceInvalidChars\n      });\n    }\n  } else {\n    parentElement.text({\n      charData: str,\n      replaceInvalidCharsInCharData: options.replaceInvalidChars\n    });\n  }\n}\n/**\n * Parses an attribute into XML and adds it to the parent element.\n *\n * @private\n */\n\n\nfunction parseAttribute(name, value, parentElement, options) {\n  var attribute = parentElement.attribute({\n    name: name,\n    replaceInvalidCharsInName: options.replaceInvalidChars\n  });\n  parseString(utils_1.stringify(value), attribute, options);\n}\n/**\n * Parses an object or Map entry into XML and adds it to the parent element.\n *\n * @private\n */\n\n\nfunction parseObjectOrMapEntry(key, value, parentElement, options) {\n  // Alias key\n  if (key === options.aliasString) {\n    parentElement.name = utils_1.stringify(value);\n    return;\n  } // Attributes key\n\n\n  if (key.indexOf(options.attributeString) === 0) {\n    for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {\n      var subkey = _a[_i];\n      parseAttribute(subkey, utils_1.stringify(value[subkey]), parentElement, options);\n    }\n\n    return;\n  } // Value key\n\n\n  if (key.indexOf(options.valueString) === 0) {\n    parseValue(key, utils_1.stringify(value), parentElement, options);\n    return;\n  } // Standard handling (create new element for entry)\n\n\n  var element = parentElement;\n\n  if (!utils_1.isArray(value) && !utils_1.isSet(value)) {\n    // If handler for value returns absent, then do not add element\n    var handler = getHandler(value, options);\n\n    if (!utils_1.isUndefined(handler)) {\n      if (handler(value) === Absent.instance) {\n        return;\n      }\n    }\n\n    element = parentElement.element({\n      name: key,\n      replaceInvalidCharsInName: options.replaceInvalidChars,\n      useSelfClosingTagIfEmpty: options.useSelfClosingTagIfEmpty\n    });\n  }\n\n  parseValue(key, value, element, options);\n}\n/**\n * Parses an Object or Map into XML and adds it to the parent element.\n *\n * @private\n */\n\n\nfunction parseObjectOrMap(objectOrMap, parentElement, options) {\n  if (utils_1.isMap(objectOrMap)) {\n    objectOrMap.forEach(function (value, key) {\n      parseObjectOrMapEntry(utils_1.stringify(key), value, parentElement, options);\n    });\n  } else {\n    for (var _i = 0, _a = Object.keys(objectOrMap); _i < _a.length; _i++) {\n      var key = _a[_i];\n      parseObjectOrMapEntry(key, objectOrMap[key], parentElement, options);\n    }\n  }\n}\n/**\n * Parses an array or Set into XML and adds it to the parent element.\n *\n * @private\n */\n\n\nfunction parseArrayOrSet(key, arrayOrSet, parentElement, options) {\n  var arrayNameFunc;\n\n  if (options.wrapHandlers.hasOwnProperty(\"*\")) {\n    arrayNameFunc = options.wrapHandlers[\"*\"];\n  }\n\n  if (options.wrapHandlers.hasOwnProperty(key)) {\n    arrayNameFunc = options.wrapHandlers[key];\n  }\n\n  var arrayKey = key;\n  var arrayElement = parentElement;\n\n  if (!utils_1.isUndefined(arrayNameFunc)) {\n    var arrayNameFuncKey = arrayNameFunc(arrayKey, arrayOrSet);\n\n    if (!utils_1.isNull(arrayNameFuncKey)) {\n      arrayKey = arrayNameFuncKey;\n      arrayElement = parentElement.element({\n        name: key,\n        replaceInvalidCharsInName: options.replaceInvalidChars,\n        useSelfClosingTagIfEmpty: options.useSelfClosingTagIfEmpty\n      });\n    }\n  }\n\n  arrayOrSet.forEach(function (item) {\n    var element = arrayElement;\n\n    if (!utils_1.isArray(item) && !utils_1.isSet(item)) {\n      // If handler for value returns absent, then do not add element\n      var handler = getHandler(item, options);\n\n      if (!utils_1.isUndefined(handler)) {\n        if (handler(item) === Absent.instance) {\n          return;\n        }\n      }\n\n      element = arrayElement.element({\n        name: arrayKey,\n        replaceInvalidCharsInName: options.replaceInvalidChars,\n        useSelfClosingTagIfEmpty: options.useSelfClosingTagIfEmpty\n      });\n    }\n\n    parseValue(arrayKey, item, element, options);\n  });\n}\n/**\n * Parses an arbitrary JavaScript value into XML and adds it to the parent\n * element.\n *\n * @private\n */\n\n\nfunction parseValue(key, value, parentElement, options) {\n  // If a handler for a particular type is user-defined, use that handler\n  // instead of the defaults\n  var handler = getHandler(value, options);\n\n  if (!utils_1.isUndefined(handler)) {\n    value = handler(value);\n  }\n\n  if (utils_1.isObject(value) || utils_1.isMap(value)) {\n    parseObjectOrMap(value, parentElement, options);\n    return;\n  }\n\n  if (utils_1.isArray(value) || utils_1.isSet(value)) {\n    parseArrayOrSet(key, value, parentElement, options);\n    return;\n  }\n\n  parseString(utils_1.stringify(value), parentElement, options);\n}\n/**\n * Converts the specified object to XML and adds the XML representation to the\n * specified XmlDocument object using the specified options.\n *\n * This function does not add a root element. In addition, it does not add an\n * XML declaration or DTD, and the associated options in {@link IOptions} are\n * ignored. If desired, these must be added manually.\n */\n\n\nfunction parseToExistingElement(element, object, options) {\n  var opts = new options_1.Options(options);\n  parseValue(element.name, object, element, opts);\n}\n\nexports.parseToExistingElement = parseToExistingElement;\n/**\n * Returns a XML string representation of the specified object using the\n * specified options.\n *\n * `root` is the name of the root XML element. When the object is converted\n * to XML, it will be a child of this root element.\n */\n\nfunction parse(root, object, options) {\n  var opts = new options_1.Options(options);\n  var document = new xmlcreate_1.XmlDocument({\n    validation: opts.validation\n  });\n\n  if (opts.declaration.include) {\n    document.decl(opts.declaration);\n  }\n\n  if (opts.dtd.include) {\n    document.dtd({\n      // Validated in options.ts\n      name: opts.dtd.name,\n      pubId: opts.dtd.pubId,\n      sysId: opts.dtd.sysId\n    });\n  }\n\n  var rootElement = document.element({\n    name: root,\n    replaceInvalidCharsInName: opts.replaceInvalidChars,\n    useSelfClosingTagIfEmpty: opts.useSelfClosingTagIfEmpty\n  });\n  parseToExistingElement(rootElement, object, options);\n  return document.toString(opts.format);\n}\n\nexports.parse = parse;","map":null,"metadata":{},"sourceType":"script"}