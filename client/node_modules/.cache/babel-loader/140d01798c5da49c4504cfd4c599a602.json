{"ast":null,"code":"//copyright Ryan Day 2010 <http://ryanday.org>, Joscha Feth 2013 <http://www.feth.com> [MIT Licensed]\nvar element_start_char = \"a-zA-Z_\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FFF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\nvar element_non_start_char = \"-.0-9\\xB7\\u0300-\\u036F\\u203F\\u2040\";\nvar element_replace = new RegExp(\"^([^\" + element_start_char + \"])|^((x|X)(m|M)(l|L))|([^\" + element_start_char + element_non_start_char + \"])\", \"g\");\nvar not_safe_in_xml = /[^\\x09\\x0A\\x0D\\x20-\\xFF\\x85\\xA0-\\uD7FF\\uE000-\\uFDCF\\uFDE0-\\uFFFD]/gm;\n\nvar process_to_xml = function process_to_xml(node_data, options) {\n  var makeNode = function makeNode(name, content, attributes, level, hasSubNodes) {\n    var indent_value = options.indent !== undefined ? options.indent : \"\\t\";\n    var indent = options.prettyPrint ? '\\n' + new Array(level).join(indent_value) : '';\n\n    if (options.removeIllegalNameCharacters) {\n      name = name.replace(element_replace, '_');\n    }\n\n    var node = [indent, '<', name, attributes || ''];\n\n    if (content && content.length > 0 || options.html) {\n      node.push('>');\n      node.push(content);\n      hasSubNodes && node.push(indent);\n      node.push('</');\n      node.push(name);\n      node.push('>');\n    } else {\n      node.push('/>');\n    }\n\n    return node.join('');\n  };\n\n  return function fn(node_data, node_descriptor, level) {\n    var type = typeof node_data;\n\n    if (Array.isArray ? Array.isArray(node_data) : node_data instanceof Array) {\n      type = 'array';\n    } else if (node_data instanceof Date) {\n      type = 'date';\n    }\n\n    switch (type) {\n      //if value is an array create child nodes from values\n      case 'array':\n        var ret = [];\n        node_data.map(function (v) {\n          ret.push(fn(v, 1, level + 1)); //entries that are values of an array are the only ones that can be special node descriptors\n        });\n        options.prettyPrint && ret.push('\\n');\n        return ret.join('');\n        break;\n\n      case 'date':\n        // cast dates to ISO 8601 date (soap likes it)\n        return node_data.toJSON ? node_data.toJSON() : node_data + '';\n        break;\n\n      case 'object':\n        if (node_descriptor == 1 && node_data.name) {\n          var content = [],\n              attributes = [];\n\n          if (node_data.attrs) {\n            if (typeof node_data.attrs != 'object') {\n              // attrs is a string, etc. - just use it as an attribute\n              attributes.push(' ');\n              attributes.push(node_data.attrs);\n            } else {\n              for (var key in node_data.attrs) {\n                var value = node_data.attrs[key];\n                attributes.push(' ');\n                attributes.push(key);\n                attributes.push('=\"');\n                attributes.push(options.escape ? esc(value) : value);\n                attributes.push('\"');\n              }\n            }\n          } //later attributes can be added here\n\n\n          if (typeof node_data.value != 'undefined') {\n            var c = '' + node_data.value;\n            content.push(options.escape && !node_data.noescape ? esc(c) : c);\n          } else if (typeof node_data.text != 'undefined') {\n            var c = '' + node_data.text;\n            content.push(options.escape && !node_data.noescape ? esc(c) : c);\n          }\n\n          if (node_data.children) {\n            content.push(fn(node_data.children, 0, level + 1));\n          }\n\n          return makeNode(node_data.name, content.join(''), attributes.join(''), level, !!node_data.children);\n        } else {\n          var nodes = [];\n\n          for (var name in node_data) {\n            nodes.push(makeNode(name, fn(node_data[name], 0, level + 1), null, level + 1));\n          }\n\n          options.prettyPrint && nodes.length > 0 && nodes.push('\\n');\n          return nodes.join('');\n        }\n\n        break;\n\n      case 'function':\n        return node_data();\n        break;\n\n      default:\n        return options.escape ? esc(node_data) : '' + node_data;\n    }\n  }(node_data, 0, 0);\n};\n\nvar xml_header = function xml_header(standalone) {\n  var ret = ['<?xml version=\"1.0\" encoding=\"utf-8\"'];\n\n  if (standalone) {\n    ret.push(' standalone=\"yes\"');\n  }\n\n  ret.push('?>');\n  return ret.join('');\n};\n\nmodule.exports = function (obj, options) {\n  var Buf = typeof Buffer !== 'undefined' ? Buffer : function Buffer() {};\n\n  if (typeof obj == 'string' || obj instanceof Buf) {\n    try {\n      obj = JSON.parse(obj.toString());\n    } catch (e) {\n      return false;\n    }\n  }\n\n  var xmlheader = '';\n  var docType = '';\n\n  if (options) {\n    if (typeof options == 'object') {\n      // our config is an object\n      if (options.xmlHeader) {\n        // the user wants an xml header\n        xmlheader = xml_header(!!options.xmlHeader.standalone);\n      }\n\n      if (typeof options.docType != 'undefined') {\n        docType = '<!DOCTYPE ' + options.docType + '>';\n      }\n    } else {\n      // our config is a boolean value, so just add xml header\n      xmlheader = xml_header();\n    }\n  }\n\n  options = options || {};\n  var ret = [xmlheader, options.prettyPrint && docType ? '\\n' : '', docType, process_to_xml(obj, options)];\n  return ret.join('');\n};\n\nmodule.exports.json_to_xml = module.exports.obj_to_xml = module.exports;\nmodule.exports.escape = esc;\n\nfunction esc(str) {\n  return ('' + str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&apos;').replace(/\"/g, '&quot;').replace(not_safe_in_xml, '');\n}\n\nmodule.exports.cdata = cdata;\n\nfunction cdata(str) {\n  if (str) return \"<![CDATA[\" + str.replace(/]]>/g, '') + ']]>';\n  return \"<![CDATA[]]>\";\n}\n\n;","map":null,"metadata":{},"sourceType":"script"}